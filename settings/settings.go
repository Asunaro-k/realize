package settings

import (
	yaml "gopkg.in/yaml.v2"
	"os"
	"path/filepath"
	"time"
)

// settings const
const (
	Interval   = 200
	Permission = 0775
	Directory  = ".realize"
	File       = "realize.yaml"
	FileOut    = "outputs.log"
	FileErr    = "errors.log"
	FileLog    = "logs.log"
)

// Settings defines a group of general settings and options
type Settings struct {
	File      string `yaml:"-" json:"-"`
	Make      bool   `yaml:"-" json:"-"`
	Files     `yaml:"files" json:"files"`
	Legacy    `yaml:"legacy,omitempty" json:"legacy,omitempty"`
	Server    `yaml:"server,omitempty" json:"server,omitempty"`
	FileLimit int64 `yaml:"flimit,omitempty" json:"flimit,omitempty"`
}

// Legacy configuration
type Legacy struct {
	Interval time.Duration `yaml:"interval" json:"interval"`
}

// Server settings, used for the web panel
type Server struct {
	Status bool   `yaml:"status" json:"status"`
	Open   bool   `yaml:"open" json:"open"`
	Host   string `yaml:"host" json:"host"`
	Port   int    `yaml:"port" json:"port"`
}

// Files defines the files generated by realize
type Files struct {
	Outputs Resource `yaml:"outputs,omitempty" json:"outputs,omitempty"`
	Logs    Resource `yaml:"logs,omitempty" json:"log,omitempty"`
	Errors  Resource `yaml:"errors,omitempty" json:"error,omitempty"`
}

// Resource status and file name
type Resource struct {
	Status bool
	Name   string
}

// Read from config file
func (s *Settings) Read(out interface{}) error {
	localConfigPath := s.File
	// backward compatibility
	path := filepath.Join(Directory, s.File)
	if _, err := os.Stat(path); err == nil {
		localConfigPath = path
	}
	content, err := s.Stream(localConfigPath)
	if err == nil {
		err = yaml.Unmarshal(content, out)
		return err
	}
	return err
}

// Record create and unmarshal the yaml config file
func (s *Settings) Record(out interface{}) error {
	if s.Make {
		y, err := yaml.Marshal(out)
		if err != nil {
			return err
		}
		if _, err := os.Stat(Directory); os.IsNotExist(err) {
			if err = os.Mkdir(Directory, Permission); err != nil {
				return s.Write(s.File, y)
			}
		}
		return s.Write(filepath.Join(Directory, s.File), y)
	}
	return nil
}

// Remove realize folder
func (s *Settings) Remove(d string) error {
	_, err := os.Stat(d)
	if !os.IsNotExist(err) {
		return os.RemoveAll(d)
	}
	return err
}
